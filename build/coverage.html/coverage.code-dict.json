{"/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/test.js":"/* istanbul instrument in package npmtest_node_cassandra_cql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/lib.npmtest_node_cassandra_cql.js":"/* istanbul instrument in package npmtest_node_cassandra_cql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_cassandra_cql = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_cassandra_cql = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-cassandra-cql && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_cassandra_cql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_cassandra_cql\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_cassandra_cql.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_cassandra_cql.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_cassandra_cql.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_cassandra_cql.__dirname + '/lib.npmtest_node_cassandra_cql.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/index.js":"var events = require('events');\nvar util = require('util');\nvar async = require('async');\nvar Connection = require('./lib/connection.js').Connection;\nvar utils = require('./lib/utils.js');\nvar types = require('./lib/types.js');\n\nvar optionsDefault = {\n  version: '3.0.0',\n  //max simultaneous requests (before waiting for a response) (max=128) on each connection\n  maxRequests: 32,\n  //When the simultaneous requests has been reached, it determines the amount of milliseconds before retrying to get an available streamId\n  maxRequestsRetry: 100,\n  //Time that has to pass before trying to reconnect\n  staleTime: 1000,\n  //maximum amount of times an execute can be retried (using another connection) because of an unhealthy server response\n  maxExecuteRetries: 3,\n  //maximum time (in milliseconds) to get a healthy connection from the pool. It should be connection Timeout * n.\n  getAConnectionTimeout: 3500,\n  //number of connections to open for each host\n  poolSize: 1\n};\n//Represents a pool of connection to multiple hosts\nfunction Client(options) {\n  events.EventEmitter.call(this);\n  //Unlimited amount of listeners for internal event queues by default\n  this.setMaxListeners(0);\n  this.options = utils.extend({}, optionsDefault, options);\n  //current connection index\n  this.connectionIndex = 0;\n  //current connection index for prepared queries\n  this.prepareConnectionIndex = 0;\n  this.preparedQueries = {};\n  \n  this._createPool();\n}\n\nutil.inherits(Client, events.EventEmitter);\n\n/**\n * Creates the pool of connections suitable for round robin\n */\nClient.prototype._createPool = function () {\n  this.connections = [];\n  for (var poolIndex = 0; poolIndex < this.options.poolSize; poolIndex++) {\n    for (var i = 0; i < this.options.hosts.length; i++) {\n      var host = this.options.hosts[i].split(':');\n      var connOptions = utils.extend({}, this.options, {host: host[0], port: host[1] || 9042});\n      var c = new Connection(connOptions);\n      c.indexInPool = (this.options.poolSize * poolIndex) + i;\n      this.connections.push(c);\n    }\n  }\n\n  this.emit('log', 'info', this.connections.length + ' connections created across ' + this.options.hosts.length + ' hosts.');\n};\n\n/**\n * Connects to each host\n */\nClient.prototype._connectAllHosts = function (connectCallback) {\n  this.emit('log', 'info', 'Connecting to all hosts');\n  var errors = [];\n  this.connecting = true;\n  var self = this;\n  async.each(this.connections, \n    function (c, callback) {\n      c.open(function (err) {\n        if (err) {\n          self._setUnhealthy(c);\n          errors.push(err);\n          self.emit('log', 'error', 'There was an error opening connection #' + c.indexInPool, err);\n        }\n        else {\n          self.emit('log', 'info', 'Opened connection #' + c.indexInPool);\n        }\n        callback();\n      });\n    },\n    function () {\n      self.connecting = false;\n      var error = null;\n      if (errors.length === self.connections.length) {\n        error = new PoolConnectionError(errors);\n      }\n      self.connected = !error;\n      connectCallback(error);\n      self.emit('connection', error);\n    });\n};\n\n/** \n * Connects to all hosts, in case the pool is disconnected.\n * @param {function} callback is called when the pool is connected (or at least 1 connected and the rest failed to connect) or it is not possible to connect \n */\nClient.prototype.connect = function (callback) {\n  if (!callback) {\n    callback = function () {};\n  }\n  if (this.connected || this.connectionError) {\n    callback(this.connectionError);\n    return;\n  }\n  if (this.connecting) {\n    //queue while is connecting\n    this.emit('log', 'info', 'Waiting for the pool to connect');\n    this.once('connection', callback);\n    return;\n  }\n  //it is the first time. Try to connect to all hosts\n  var self = this;\n  this.connecting = true;\n  this._connectAllHosts(function (err) {\n    if (err) {\n      self.connectionError = err;\n    }\n    callback(err);\n  });\n};\n\n/**\n * Gets a live connection\n * If there isn't an active connection available, it calls the callback with the error.\n */\nClient.prototype._getAConnection = function (callback) {\n  var self = this;\n  self.connect(function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    //go through the connections\n    //watch out for infinite loops\n    var startTime = Date.now();\n    function checkNextConnection (callback) {\n      self.emit('log', 'info', 'Checking next connection');\n      self.connectionIndex = self.connectionIndex + 1;\n      if (self.connectionIndex > self.connections.length-1) {\n        self.connectionIndex = 0;\n      }\n      var c = self.connections[self.connectionIndex];      \n      if (self._isHealthy(c)) {\n        callback(null, c);\n      }\n      else if (Date.now() - startTime > self.options.getAConnectionTimeout) {\n        callback(new types.TimeoutError('Get a connection timed out'));\n      }\n      else if (!c.connecting && self._canReconnect(c)) {\n        self.emit('log', 'info', 'Retrying to open #' + c.indexInPool);\n        //try to reconnect\n        c.open(function(err){\n          if (err) {\n            //This connection is still not good, go for the next one\n            self._setUnhealthy(c);\n            setImmediate(function () {\n              checkNextConnection(callback);\n            });\n          }\n          else {\n            //this connection is now good\n            self._setHealthy(c);\n            callback(null, c);\n          }\n        });\n      }\n      else {\n        //this connection is not good, try the next one\n        setImmediate(function () {\n          checkNextConnection(callback);\n        });\n      }\n    }\n    checkNextConnection(callback);\n  });\n};\n\n/**\n * Executes a query in an available connection.\n * @param {String} query The query to execute\n * @param {Array} [param] Array of params to replace\n * @param {Number} [consistency] Consistency level\n * @param [options]\n * @param {function} callback Executes callback(err, result) when finished\n */\nClient.prototype.execute = function () {\n  var args = utils.parseCommonArgs.apply(null, arguments);\n  var self = this;\n  //Get stack trace before sending query so the user knows where errored\n  //queries come from\n  var stackContainer = {};\n  Error.captureStackTrace(stackContainer);\n\n  function tryAndRetry(retryCount) {\n    retryCount = retryCount || 0;\n    self._getAConnection(function(err, c) {\n      if (err) {\n        args.callback(err);\n        return;\n      }\n      self.emit('log', 'info', 'connection #' + c.indexInPool + ' acquired, executing: ' + args.query);\n      c.execute(args.query, args.params, args.consistency, function(err, result) {\n        //Determine if its a fatal error\n        if (self._isServerUnhealthy(err)) {\n          //if its a fatal error, the server died\n          self._setUnhealthy(c);\n          if (retryCount === self.options.maxExecuteRetries) {\n            args.callback(err, result, retryCount);\n            return;\n          }\n          //retry: it will get another connection\n          self.emit('log', 'error', 'There was an error executing a query, retrying execute (will get another connection)', err);\n          tryAndRetry(retryCount+1);\n        }\n        else {\n          if (err) {\n            utils.fixStack(stackContainer.stack, err);\n            err.query = args.query;\n          }\n          //If the result is OK or there is error (syntax error or an unauthorized for example), callback\n          args.callback(err, result);\n        }\n      });\n    });\n  }\n  tryAndRetry(0);\n};\n\n/**\n * Prepares (the first time) and executes the prepared query, retrying on multiple hosts if needed.\n * @param {String} query The query to prepare and execute\n * @param {Array} [param] Array of params\n * @param {Number} [consistency] Consistency level\n * @param [options]\n * @param {function} callback Executes callback(err, result) when finished\n */\nClient.prototype.executeAsPrepared = function () {\n  var args = utils.parseCommonArgs.apply(null, arguments);\n  var self = this;\n  //Get stack trace before sending query so the user knows where errored\n  //queries come from\n  var stackContainer = {};\n  Error.captureStackTrace(stackContainer);\n\n  self._getPrepared(args.query, function preparedCallback(err, con, queryId) {\n    if (self._isServerUnhealthy(err)) {\n      //its a fatal error, the server died\n      self._setUnhealthy(con);\n      args.options = utils.extend({retryCount: 0}, args.options);\n      if (args.options.retryCount === self.options.maxExecuteRetries) {\n        return args.callback(err);\n      }\n      //retry: it will get another connection\n      self.emit('log', 'info', 'Retrying to prepare \"' + args.query + '\"');\n      args.options.retryCount = args.options.retryCount + 1;\n      self.executeAsPrepared(args.query, args.params, args.consistency, args.options, args.callback);\n    }\n    else if (err) {\n      //its syntax or other normal error\n      utils.fixStack(stackContainer.stack, err);\n      err.query = args.query;\n      if (args.options && args.options.resultStream) {\n        args.options.resultStream.emit('error', err);\n      }\n      args.callback(err);\n    }\n    else {\n      //it is prepared on the connection\n      self._executeOnConnection(con, args.query, queryId, args.params,args.consistency, args.options, args.callback);\n    }\n  });\n};\n\n/**\n * Prepares (the first time on each host), executes the prepared query and streams the last field of each row.\n * It executes the callback per each row as soon as the first chunk of the last field is received.\n * Retries on multiple hosts if needed.\n * @param {String} query The query to prepare and execute\n * @param {Array} [param] Array of params\n * @param {Number} [consistency] Consistency level\n * @param [options]\n * @param {function} rowCallback Executes rowCallback(n, row, fieldStream) per each row\n * @param {function} [callback] Executes callback(err) when finished or there is an error\n */\nClient.prototype.streamField = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var rowCallback;\n  //accepts an extra callback\n  if(typeof args[args.length-1] === 'function' && typeof args[args.length-2] === 'function') {\n    //pass it through the options parameter\n    rowCallback = args.splice(args.length-2, 1)[0];\n  }\n  args = utils.parseCommonArgs.apply(null, args);\n  if (!rowCallback) {\n    //only one callback has been defined\n    rowCallback = args.callback;\n    args.callback = function () {};\n  }\n  args.options = utils.extend({}, args.options, {\n    byRow: true,\n    streamField: true,\n    rowCallback: rowCallback\n  });\n  this.executeAsPrepared(args.query, args.params, args.consistency, args.options, args.callback);\n};\n\n/**\n * Prepares (the first time), executes the prepared query and calls rowCallback for each row as soon as they are received.\n * Calls endCallback after all rows have been sent, or when there is an error.\n * Retries on multiple hosts if needed.\n * @param {String} query The query to prepare and execute\n * @param {Array} [param] Array of params\n * @param {Number} [consistency] Consistency level\n * @param [options]\n * @param {function} rowCallback, executes callback(n, row) per each row received. (n = index)\n * @param {function} [endcallback], executes endCallback(err, totalCount) after all rows have been received.\n */\nClient.prototype.eachRow = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var rowCallback;\n  //accepts an extra callback\n  if(typeof args[args.length-1] === 'function' && typeof args[args.length-2] === 'function') {\n    //pass it through the options parameter\n    rowCallback = args.splice(args.length-2, 1)[0];\n  }\n  args = utils.parseCommonArgs.apply(null, args);\n  if (!rowCallback) {\n    //only one callback has been defined\n    rowCallback = args.callback;\n    args.callback = function () {};\n  }\n  args.options = utils.extend({}, args.options, {\n    byRow: true,\n    rowCallback: rowCallback\n  });\n  this.executeAsPrepared(args.query, args.params, args.consistency, args.options, args.callback);\n};\n\n\n/**\n * Prepares (the first time), executes the prepared query and pushes the rows to the result stream\n *  as soon as they received.\n * Calls callback after all rows have been sent, or when there is an error.\n * Retries on multiple hosts if needed.\n * @param {String} query The query to prepare and execute\n * @param {Array} [param] Array of params\n * @param {Number} [consistency] Consistency level\n * @param [options]\n * @param {function} [callback], executes callback(err) after all rows have been received or if there is an error\n * @returns {ResultStream}\n */\nClient.prototype.stream = function () {\n  var args = Array.prototype.slice.call(arguments);\n  if (typeof args[args.length-1] !== 'function') {\n    //the callback is not required\n    args.push(function noop() {});\n  }\n  args = utils.parseCommonArgs.apply(null, args);\n  var resultStream = new types.ResultStream({objectMode: 1})\n  args.options = utils.extend({}, args.options, {resultStream: resultStream});\n  this.executeAsPrepared(args.query, args.params, args.consistency, args.options, args.callback);\n  return resultStream;\n};\n\nClient.prototype.streamRows = Client.prototype.eachRow;\n\nClient.prototype.executeBatch = function () {\n  throw new Error('Method not supported by this version of the driver. Try using the driver version that implements Cassandra native protocol v2.');\n};\n\n/**\n * Executes a prepared query on a given connection\n */\nClient.prototype._executeOnConnection = function (c, query, queryId, params, consistency, options, callback) {\n  this.emit('log', 'info', 'Executing prepared query \"' + query + '\"');\n  var self = this;\n  c.executePrepared(queryId, params, consistency, options, function(err, result1, result2) {\n    if (self._isServerUnhealthy(err)) {\n      //There is a problem with the connection/server that had a prepared query\n      //forget about this connection for now\n      self._setUnhealthy(c);\n      //retry the whole thing, it will get another connection\n      self.executeAsPrepared(query, params, consistency, options, callback);\n    }\n    else if (err && err.code === types.responseErrorCodes.unprepared) {\n      //Query expired at the server\n      //Clear the connection from prepared info and\n      //trying to re-prepare query\n      self.emit('log', 'info', 'Unprepared query \"' + query + '\"');\n      var preparedInfo = self.preparedQueries[query];\n      preparedInfo.removeConnectionInfo(c.indexInPool);\n      self.executeAsPrepared(query, params, consistency, options, callback);\n    }\n    else {\n      callback(err, result1, result2);\n    }\n  });\n};\n\n/**\n * It gets an active connection and prepares the query on it, queueing the callback in case its already prepared.\n * @param {String} query Query to prepare with ? as placeholders\n * @param {function} callback Executes callback(err, con, queryId) when there is a prepared statement on a connection or there is an error.\n */\nClient.prototype._getPrepared = function (query, callback) {\n  var preparedInfo = this.preparedQueries[query];\n  if (!preparedInfo) {\n    preparedInfo = new PreparedInfo(query);\n    this.preparedQueries[query] = preparedInfo;\n  }\n  var self = this;\n  this._getAConnection(function(err, con) {\n    if (err) {\n      return callback(err);\n    }\n    var conInfo = preparedInfo.getConnectionInfo(con.indexInPool);\n    if (conInfo.queryId !== null) {\n      //is already prepared on this connection\n      return callback(null, con, conInfo.queryId);\n    }\n    else if (conInfo.preparing) {\n      //Its being prepared, queue until finish\n      return conInfo.once('prepared', callback);\n    }\n    //start preparing\n    conInfo.preparing = true;\n    conInfo.once('prepared', callback);\n    return self._prepare(conInfo, con, query);\n  });\n};\n\n/**\n * Prepares a query on a connection. If it fails (server unhealthy) it retries all the preparing process with a new connection.\n */\nClient.prototype._prepare = function (conInfo, con, query) {\n  this.emit('log', 'info', 'Preparing the query \"' + query + '\" on connection #' + con.indexInPool);\n  var self = this;\n  con.prepare(query, function (err, result) {\n    conInfo.preparing = false;\n    if (!err) {\n      self._setAsPrepared(conInfo, query, result.id);\n    }\n    conInfo.emit('prepared', err, con, result ? result.id : null);\n  });\n};\n\n\nClient.prototype._setAsPrepared = function (conInfo, query, queryId) {\n  conInfo.queryId = queryId;\n  var preparedOnConnection = this.preparedQueries[\"_\" + conInfo.id];\n  if (!preparedOnConnection) {\n    preparedOnConnection = [];\n    this.preparedQueries[\"_\" + conInfo.id] = preparedOnConnection;\n  }\n  preparedOnConnection.push(query);\n};\n/**\n * Removes all previously stored queries assigned to a connection\n */\nClient.prototype._removeAllPrepared = function (con) {\n  var conKey = \"_\" + con.indexInPool;\n  var preparedOnConnection = this.preparedQueries[conKey];\n  if (!preparedOnConnection) {\n    return;\n  }\n  for (var i = 0; i < preparedOnConnection.length; i++) {\n    var query = preparedOnConnection[i];\n    this.preparedQueries[query].removeConnectionInfo(con.indexInPool);\n  }\n  this.emit('log', 'info', 'Removed ' + preparedOnConnection.length + ' prepared queries for con #' + con.indexInPool);\n  delete this.preparedQueries[conKey];\n};\n\nClient.prototype._isServerUnhealthy = function (err) {\n  return err && err.isServerUnhealthy;\n};\n\nClient.prototype._setUnhealthy = function (connection) {\n  if (!connection.unhealthyAt) {\n    this.emit('log', 'error', 'Connection #' + connection.indexInPool + ' is being set to Unhealthy');\n    connection.unhealthyAt = new Date().getTime();\n    this._removeAllPrepared(connection);\n  }\n};\n\nClient.prototype._setHealthy = function (connection) {\n  connection.unhealthyAt = 0;\n  this.emit('log', 'info', 'Connection #' + connection.indexInPool + ' was set to healthy');\n};\n\nClient.prototype._canReconnect = function (connection) {\n  var timePassed = new Date().getTime() - connection.unhealthyAt;\n  return timePassed > this.options.staleTime;\n};\n\n/**\n * Determines if a connection can be used\n*/\nClient.prototype._isHealthy = function (connection) {\n  return !connection.unhealthyAt;\n};\n\n/**\n * Closes all connections\n */\nClient.prototype.shutdown = function (callback) {\n  async.each(this.connections, function(c, eachCallback) {\n    c.close(eachCallback);\n  }, function() {\n    if (callback) {\n      callback();\n    }\n  });\n};\n\n/**\n * Holds the information of the connections in which a query is prepared \n */\nfunction PreparedInfo(query) {\n  this.query = query;\n  //stores information for the prepared statement on a connection\n  this._connectionData = {};\n}\n\nPreparedInfo.prototype.getConnectionInfo = function (conId) {\n  conId = conId.toString();\n  var info = this._connectionData[conId];\n  if (!info) {\n    info = new events.EventEmitter();\n    info.setMaxListeners(0);\n    info.preparing = false;\n    info.queryId = null;\n    info.id = conId;\n    this._connectionData[conId] = info;\n  }\n  return info;\n};\n\nPreparedInfo.prototype.removeConnectionInfo = function (conId) {\n  delete this._connectionData[conId];\n};\n\n/**\n * Represents a error while trying to connect the pool, all the connections failed.\n */\nfunction PoolConnectionError(individualErrors) {\n  this.name = 'PoolConnectionError';\n  this.info = 'Represents a error while trying to connect the pool, all the connections failed.';\n  this.individualErrors = individualErrors;\n}\nutil.inherits(PoolConnectionError, Error);\n\nexports.Client = Client;\nexports.Connection = Connection;\nexports.types = types;\n","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/lib/connection.js":"var net = require('net');\nvar events = require('events');\nvar util = require('util');\nvar writers = require('./writers.js');\nvar streams = require('./streams.js');\nvar utils = require('./utils.js');\nvar types = require('./types.js');\n\nvar optionsDefault = {\n  port:  9042,\n  version: '3.0.0',\n  //max simultaneous requests (before waiting for a response) (max=128)\n  maxRequests: 32,\n  //When the simultaneous requests has been reached, it determines the amount of milliseconds before retrying to get an available streamId\n  maxRequestsRetry: 100,\n  //Connect timeout: time to wait when trying to connect to a host,\n  connectTimeout: 2000\n};\nfunction Connection(options) {\n  events.EventEmitter.call(this);\n\n  this.streamHandlers = {};\n  this.options = utils.extend({}, optionsDefault, options);\n}\n\nutil.inherits(Connection, events.EventEmitter);\n\nConnection.prototype.createSocket = function() {\n  var self = this;\n  if (this.netClient) {\n    this.netClient.destroy();\n  }\n  this.netClient = new net.Socket();\n  this.writeQueue = new writers.WriteQueue(this.netClient);\n  var protocol = new streams.Protocol({objectMode: true});\n  this.parser = new streams.Parser({objectMode: true});\n  var resultEmitter = new streams.ResultEmitter({objectMode: true});\n  this.netClient\n    .pipe(protocol)\n    .pipe(this.parser)\n    .pipe(resultEmitter);\n\n  resultEmitter.on('result', this.handleResult.bind(this));\n  resultEmitter.on('row', this.handleRow.bind(this));\n  resultEmitter.on('frameEnded', this.freeStreamId.bind(this));\n  \n  this.netClient.on('close', function() {\n    self.emit('log', 'info', 'Socket disconnected');\n    self.connected = false;\n    self.connecting = false;\n    self.invokePendingCallbacks();\n  });\n};\n\n/** \n * Connects a socket and sends the startup protocol messages, including authentication and the keyspace used. \n */\nConnection.prototype.open = function (callback) {\n  var self = this;\n  self.emit('log', 'info', 'Connecting to ' + this.options.host + ':' + this.options.port);\n  self.createSocket();\n  self.connecting = true;\n  function errorConnecting (err, destroy) {\n    self.connecting = false;\n    if (destroy) {\n      //there is a TCP connection that should be killed.\n      self.netClient.destroy();\n    }\n    callback(err);\n  }\n  this.netClient.once('error', errorConnecting);\n  this.netClient.once('timeout', function connectTimeout() {\n    var err = new types.DriverError('Connection timeout');\n    errorConnecting(err, true);\n  });\n  this.netClient.setTimeout(this.options.connectTimeout);\n  \n  this.netClient.connect(this.options.port, this.options.host, function connectCallback() {\n    self.emit('log', 'info', 'Socket connected to ' + self.options.host + ':' + self.options.port);\n    self.netClient.removeListener('error', errorConnecting);\n    self.netClient.removeAllListeners('connect');\n    self.netClient.removeAllListeners('timeout');\n    \n    self.sendStream(new writers.StartupWriter(self.options.version), null, function (err, response) {\n      if (response && response.mustAuthenticate) {\n        return self.authenticate(startupCallback);\n      }\n      startupCallback(err);\n    });\n  });\n\n  function startupCallback(err) {\n    if (err) {\n      return errorConnecting(err, true);\n    }\n    //The socket is connected and the connection is authenticated\n    if (!self.options.keyspace) {\n      return self.connectionReady(callback);\n    }\n    //Use the keyspace\n    self.execute('USE ' + self.options.keyspace + ';', null, function (err) {\n      if (err) {\n        return errorConnecting(err, true);\n      }\n      self.connectionReady(callback);\n    });\n  }\n};\n\n/**\n * Sets the connection to ready/connected status\n */\nConnection.prototype.connectionReady = function (callback) {\n  this.emit('connected');\n  this.connected = true;\n  this.connecting = false;\n  this.netClient.on('error', this.handleSocketError.bind(this));\n  callback();\n};\n\n/**\n * Handle socket errors, if the socket is not readable invoke all pending callbacks\n */\nConnection.prototype.handleSocketError = function (err) {\n  this.emit('log', 'error', 'Socket error ' + err, 'r/w:', this.netClient.readable, this.netClient.writable);\n  this.invokePendingCallbacks(err);\n};\n\n/**\n * Invokes all pending callback of sent streams\n */\nConnection.prototype.invokePendingCallbacks = function (innerError) {\n  var err = new types.DriverError('Socket was closed');\n  err.isServerUnhealthy = true;\n  if (innerError) {\n    err.innerError = innerError;\n  }\n  //invoke all pending callbacks\n  var handlers = [];\n  for (var streamId in this.streamHandlers) {\n    if (this.streamHandlers.hasOwnProperty(streamId)) {\n      handlers.push(this.streamHandlers[streamId]);\n    }\n  }\n  this.streamHandlers = {};\n  if (handlers.length > 0) {\n    this.emit('log', 'info', 'Invoking ' + handlers.length + ' pending callbacks');\n  }\n  handlers.forEach(function (item) {\n    if (!item.callback) return;\n    item.callback(err);\n  });\n};\n\nConnection.prototype.authenticate = function(callback) {\n  if (!this.options.username) {\n    return callback(new Error(\"Server needs authentication which was not provided\"));\n  }\n  this.sendStream(new writers.CredentialsWriter(this.options.username, this.options.password), null, callback);\n};\n/**\n * Executes a query sending a QUERY stream to the host\n */\nConnection.prototype.execute = function () {\n  var args = utils.parseCommonArgs.apply(null, arguments);\n  this.emit('log', 'info', 'executing query: ' + args.query);\n  this.sendStream(new writers.QueryWriter(args.query, args.params, args.consistency), null, args.callback);\n};\n\n/**\n * Executes a (previously) prepared statement and yields the rows into a ReadableStream\n * @returns {ResultStream}\n */\nConnection.prototype.stream = function () {\n  var args = utils.parseCommonArgs.apply(null, arguments);\n  this.emit('log', 'info', 'Executing for streaming prepared query: 0x' + args.query.toString('hex'));\n\n  var resultStream = new types.ResultStream({objectMode:true});\n  this.sendStream(\n    new writers.ExecuteWriter(args.query, args.params, args.consistency),\n    utils.extend({}, args.options, {resultStream: resultStream}),\n    args.callback);\n  return resultStream;\n};\n\n/**\n * Executes a (previously) prepared statement with a given id\n * @param {Buffer} queryId\n * @param {Array} [params]\n * @param {Number} [consistency]\n * @param [options]\n * @param {function} callback\n */\nConnection.prototype.executePrepared = function () {\n  var args = utils.parseCommonArgs.apply(null, arguments);\n  this.emit('log', 'info', 'Executing prepared query: 0x' + args.query.toString('hex'));\n  //When using each row, the final (end) callback is optional\n  if (args.options && args.options.byRow && !args.options.rowCallback) {\n    args.options.rowCallback = args.callback;\n    args.callback = null;\n  }\n  this.sendStream(\n    new writers.ExecuteWriter(args.query, args.params, args.consistency),\n    args.options,\n    args.callback);\n};\n\n/**\n * Prepares a query on a host\n * @param {String} query\n * @param {function} callback\n */\nConnection.prototype.prepare = function (query, callback) {\n  this.emit('log', 'info', 'Preparing query: ' + query);\n  this.sendStream(new writers.PrepareQueryWriter(query), null, callback);\n};\n\nConnection.prototype.register = function register (events, callback) {\n  this.sendStream(new writers.RegisterWriter(events), null, callback);\n};\n\n/**\n * Uses the frame writer to write into the wire\n * @param frameWriter\n * @param [options]\n * @param {function} [callback]\n */\nConnection.prototype.sendStream = function (frameWriter, options, callback) {\n  var self = this;\n  this.getStreamId(function (streamId) {\n    this.emit('log', 'info', 'Sending stream #' + streamId);\n    frameWriter.streamId = streamId;\n    this.writeQueue.push(frameWriter, writeCallback);\n  });\n  if (!callback) {\n    callback = function noop () {};\n  }\n\n  function writeCallback (err) {\n    if (err) {\n      if (!(err instanceof TypeError)) {\n        //TypeError is raised when there is a serialization issue\n        //If it is not a serialization issue is a socket issue\n        err.isServerUnhealthy = true;\n      }\n      return callback(err);\n    }\n    if (frameWriter instanceof writers.ExecuteWriter) {\n      if (options && options.byRow) {\n        self.parser.setOptions(frameWriter.streamId, {byRow: true, streamField: options.streamField});\n      }\n      else if (options && options.resultStream) {\n        self.parser.setOptions(frameWriter.streamId, {resultStream: options.resultStream});\n      }\n    }\n    self.emit('log', 'info', 'Sent stream #' + frameWriter.streamId);\n    self.streamHandlers[frameWriter.streamId] = {\n      callback: callback,\n      options: options};\n  }\n};\n\nConnection.prototype.getStreamId = function(callback) {\n  var self = this;\n  if (!this.availableStreamIds) {\n    this.availableStreamIds = [];\n    if (this.options.maxRequests > 128) {\n      throw new Error('Max requests can not be greater than 128');\n    }\n    for(var i = 0; i < this.options.maxRequests; i++) {\n      this.availableStreamIds.push(i);\n    }\n    this.getStreamQueue = new types.QueueWhile(function () {\n      return self.availableStreamIds.length === 0;\n    }, self.options.maxRequestsRetry);\n  }\n  this.getStreamQueue.push(function () {\n    var streamId = self.availableStreamIds.shift();\n    callback.call(self, streamId);\n  });\n};\n\nConnection.prototype.freeStreamId = function(header) {\n  var streamId = header.streamId;\n  var handler = this.streamHandlers[streamId];\n  delete this.streamHandlers[streamId];\n  this.availableStreamIds.push(streamId);\n  if(handler && handler.callback) {\n    handler.callback(null, handler.rowLength);\n  }\n  this.emit('log', 'info', 'Done receiving frame #' + streamId);\n};\n\n/**\n * Handles a result and error response\n */\nConnection.prototype.handleResult = function (header, err, result) {\n  var streamId = header.streamId;\n  if(streamId < 0) {\n    return this.emit('log', 'info', 'event received', header);\n  }\n  var handler = this.streamHandlers[streamId];\n  if (!handler) {\n    return this.emit('log', 'error', 'The server replied with a wrong streamId #' + streamId);\n  }\n  this.emit('log', 'info', 'Received frame #' + streamId);\n  var callback = handler.callback;\n  callback(err, result);\n  //set the callback to null to avoid it being called when freed\n  handler.callback = null;\n};\n\n/**\n * Handles a row response\n */\nConnection.prototype.handleRow = function (header, row, fieldStream, rowLength) {\n  var streamId = header.streamId;\n  if(streamId < 0) {\n    return this.emit('log', 'info', 'Event received', header);\n  }\n  var handler = this.streamHandlers[streamId];\n  if (!handler) {\n    return this.emit('log', 'error', 'The server replied with a wrong streamId #' + streamId);\n  }\n  this.emit('log', 'info', 'Received streaming frame #' + streamId);\n  handler.rowLength = rowLength;\n  handler.rowIndex = handler.rowIndex || 0;\n  var rowCallback = handler.options && handler.options.rowCallback;\n  if (rowCallback) {\n    rowCallback(handler.rowIndex++, row, fieldStream, rowLength);\n  }\n};\n\nConnection.prototype.close = function disconnect (callback) {\n  this.emit('log', 'info', 'disconnecting');\n  if(callback) {\n    if (!this.netClient) {\n      callback();\n      return;\n    }\n    if (!this.connected) {\n      this.netClient.destroy();\n      callback();\n      return;\n    }\n    this.netClient.on('close', function (hadError) {\n      var err = hadError ? new types.DriverError('The socket was closed due to a transmission error') : null;\n      callback(err);\n    });\n  }\n\n  this.netClient.end();\n\n  this.streamHandlers = {};\n};\n\nexports.Connection = Connection;\n","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/lib/writers.js":"var async = require('async');\nvar events = require('events');\nvar util = require('util');\n\nvar encoder = require('./encoder.js');\nvar types = require('./types.js');\nvar utils = require('./utils.js');\nvar FrameHeader = types.FrameHeader;\n/**\n * FrameWriter: Contains the logic to write all the different types to the frame.\n * Based on https://github.com/isaacbwagner/node-cql3/blob/master/lib/frameBuilder.js\n * under the MIT License https://github.com/isaacbwagner/node-cql3/blob/master/LICENSE\n */\nfunction FrameWriter(opcodename, streamId) {\n  if (!opcodename) {\n    throw new Error('Opcode not provided');\n  }\n  this.streamId = streamId;\n  this.buffers = [];\n  this.opcode = types.opcodes[opcodename.toString().toLowerCase()];\n}\n\nFrameWriter.prototype.writeShort = function(num) {\n  var buf = new Buffer(2);\n  buf.writeUInt16BE(num, 0);\n  this.buffers.push(buf);\n};\n\nFrameWriter.prototype.writeInt = function(num) {\n  var buf = new Buffer(4);\n  buf.writeInt32BE(num, 0);\n  this.buffers.push(buf);\n};\n\nFrameWriter.prototype.writeBytes = function(bytes) {\n  if(bytes === null) {\n    this.writeInt(-1);\n  } \n  else {\n    this.writeInt(bytes.length);\n    this.buffers.push(bytes);\n  }\n};\n\nFrameWriter.prototype.writeShortBytes = function(bytes) {\n  if(bytes === null) {\n    this.writeShort(-1);\n  } \n  else {\n    this.writeShort(bytes.length);\n\n    this.buffers.push(bytes);\n  }\n};\n\nFrameWriter.prototype.writeString = function(str) {\n  if (typeof str === \"undefined\") {\n    throw new Error(\"can not write undefined\");\n  }\n  var len = Buffer.byteLength(str, 'utf8');\n  var buf = new Buffer(2 + len);\n  buf.writeUInt16BE(len, 0);\n  buf.write(str, 2, buf.length-2, 'utf8');\n  this.buffers.push(buf);\n};\n\nFrameWriter.prototype.writeLString = function(str) {\n  var len = Buffer.byteLength(str, 'utf8');\n  var buf = new Buffer(4 + len);\n  buf.writeInt32BE(len, 0);\n  buf.write(str, 4, buf.length-4, 'utf8');\n  this.buffers.push(buf);\n};\n\nFrameWriter.prototype.writeStringList = function(strings) {\n  this.writeShort (strings.length);\n  var self = this;\n  strings.forEach(function(str) {\n      self.writeString(str);\n  });\n};\n\nFrameWriter.prototype.writeStringMap = function (map) {\n  var keys = [];\n  for (var k in map) {\n    if (map.hasOwnProperty(k)) {\n      keys.push(k);\n    }\n  }\n\n  this.writeShort(keys.length);\n\n  for(var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    this.writeString(key);\n    this.writeString(map[key]);\n  }\n};\n\nFrameWriter.prototype.write = function() {\n  var body = Buffer.concat(this.buffers);\n  this.streamId = parseInt(this.streamId, 10);\n  if (!(this.streamId >= 0 &&  this.streamId < 128)) {\n    throw new types.DriverError('streamId must be a number from 0 to 127');\n  }\n  var header = new FrameHeader({streamId: this.streamId, opcode: this.opcode, bodyLength: body.length});\n\n  return Buffer.concat([header.toBuffer(), body], body.length + FrameHeader.size);\n};\n\nfunction QueryWriter(query, params, consistency) {\n  this.query = query;\n  this.params = params;\n  this.consistency = consistency;\n  this.streamId = null;\n  if (consistency === null || typeof consistency === 'undefined') {\n    this.consistency = types.consistencies.getDefault();\n  }\n}\n\nQueryWriter.prototype.write = function () {\n  var frameWriter = new FrameWriter('QUERY', this.streamId);\n  var query = types.queryParser.parse(this.query, this.params, encoder.stringifyValue);\n  frameWriter.writeLString(query);\n  frameWriter.writeShort(this.consistency);\n  return frameWriter.write();\n};\n\nfunction PrepareQueryWriter(query) {\n  this.streamId = null;\n  this.query = query;\n}\n\nPrepareQueryWriter.prototype.write = function () {\n  var frameWriter = new FrameWriter('PREPARE', this.streamId);\n  frameWriter.writeLString(this.query);\n  return frameWriter.write();\n};\n\nfunction StartupWriter(cqlVersion) {\n  this.cqlVersion = cqlVersion;\n  this.streamId = null;\n}\n\nStartupWriter.prototype.write = function() {\n  var frameWriter = new FrameWriter('STARTUP', this.streamId);\n  frameWriter.writeStringMap({\n    CQL_VERSION: this.cqlVersion\n  });\n  return frameWriter.write();\n};\n\nfunction RegisterWriter(events) {\n  this.events = events;\n  this.streamId = null;\n}\n\nRegisterWriter.prototype.write = function() {\n  var frameWriter = new FrameWriter('REGISTER', this.streamId);\n  frameWriter.writeStringList(this.events);\n  return frameWriter.write();\n};\n\nfunction CredentialsWriter(username, password) {\n  this.username = username;\n  this.password = password;\n  this.streamId = null;\n}\n\nCredentialsWriter.prototype.write = function() {\n  var frameWriter = new FrameWriter('CREDENTIALS', this.streamId);\n  frameWriter.writeStringMap({username:this.username,password:this.password});\n  return frameWriter.write();\n};\n/**\n * Writes a execute query (given a prepared queryId)\n */\nfunction ExecuteWriter(queryId, params, consistency) {\n  this.queryId = queryId;\n  this.params = params ? params : [];\n  this.consistency = consistency;\n  this.streamId = null;\n  if (consistency === null || typeof consistency === 'undefined') {\n    this.consistency = types.consistencies.getDefault();\n  }\n}\n\nExecuteWriter.prototype.write = function () {\n  var frameWriter = new FrameWriter('EXECUTE', this.streamId);\n  frameWriter.writeShortBytes(this.queryId);\n  frameWriter.writeShort(this.params.length);\n  for (var i=0; i<this.params.length; i++) {\n    frameWriter.writeBytes(encoder.encode(this.params[i]));\n  }\n  frameWriter.writeShort(this.consistency);\n  return frameWriter.write();\n};\n/**\n * Represents a queue that process one write at a time (FIFO).\n */\nfunction WriteQueue (netClient) {\n  WriteQueue.super_.call(this);\n  this.isRunning = false;\n  this.queue = [];\n  this.netClient = netClient;\n}\n\nutil.inherits(WriteQueue, events.EventEmitter);\n/**\n * Pushes / enqueues\n */\nWriteQueue.prototype.push = function (writer, callback) {\n  this.queue.push({writer: writer, callback: callback});\n  this.run();\n};\n\nWriteQueue.prototype.run = function () {\n  if (!this.isRunning) {\n    this.process();\n  }\n};\n\nWriteQueue.prototype.process = function () {\n  var self = this;\n  async.whilst(\n    function () {\n      return self.queue.length > 0;\n    },\n    function (next) {\n      self.isRunning = true;\n      var writeItem = self.queue.shift();\n      var data = null;\n      var startTime = process.hrtime();\n      try {\n        data = writeItem.writer.write();\n        self.emit('perf', 'serialize', process.hrtime(startTime));\n      }\n      catch (err) {\n        writeCallback(err);\n        return;\n      }\n      self.netClient.write(data, writeCallback);\n      \n      function writeCallback(err) {\n        writeItem.callback(err);\n        //it is better to queue it up on the event loop\n        //to allow IO between writes\n        setImmediate(next);\n      }\n    },\n    function () {\n      //the queue is empty\n      self.isRunning = false;\n    }\n  );\n};\n\nexports.CredentialsWriter = CredentialsWriter;\nexports.PrepareQueryWriter = PrepareQueryWriter;\nexports.QueryWriter = QueryWriter;\nexports.RegisterWriter = RegisterWriter;\nexports.StartupWriter = StartupWriter;\nexports.ExecuteWriter = ExecuteWriter;\nexports.WriteQueue = WriteQueue;\n","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/lib/encoder.js":"var util = require('util');\r\nvar uuid = require('node-uuid');\r\n\r\nvar types = require('./types.js');\r\nvar dataTypes = types.dataTypes;\r\nvar Long = types.Long;\r\nvar utils = require('./utils.js');\r\n/**\r\n * Encodes and decodes from a type to Cassandra bytes\r\n */\r\nvar encoder = (function(){\r\n  /**\r\n   * Decodes Cassandra bytes into Javascript values.\r\n   */\r\n  function decode(bytes, type) {\r\n    if (bytes === null) {\r\n      return null;\r\n    }\r\n    switch(type[0]) {\r\n      case dataTypes.custom:\r\n      case dataTypes.decimal:\r\n      case dataTypes.inet:\r\n      case dataTypes.varint:\r\n        //return buffer and move on :)\r\n        return utils.copyBuffer(bytes);\r\n      case dataTypes.ascii:\r\n        return bytes.toString('ascii');\r\n      case dataTypes.bigint:\r\n      case dataTypes.counter:\r\n        return decodeBigNumber(utils.copyBuffer(bytes));\r\n      case dataTypes.timestamp:\r\n        return decodeTimestamp(utils.copyBuffer(bytes));\r\n      case dataTypes.blob:\r\n        return utils.copyBuffer(bytes);\r\n      case dataTypes.boolean:\r\n        return !!bytes.readUInt8(0);\r\n      case dataTypes.double:\r\n        return bytes.readDoubleBE(0);\r\n      case dataTypes.float:\r\n        return bytes.readFloatBE(0);\r\n      case dataTypes.int:\r\n        return bytes.readInt32BE(0);\r\n      case dataTypes.uuid:\r\n      case dataTypes.timeuuid:\r\n        return uuid.unparse(bytes);\r\n      case dataTypes.text:\r\n      case dataTypes.varchar:\r\n        return bytes.toString('utf8');\r\n      case dataTypes.list:\r\n      case dataTypes.set:\r\n        var list = decodeList(bytes, type[1][0]);\r\n        return list;\r\n      case dataTypes.map:\r\n        var map = decodeMap(bytes, type[1][0][0], type[1][1][0]);\r\n        return map;\r\n    }\r\n\r\n    throw new Error('Unknown data type: ' + type[0]);\r\n  }\r\n\r\n  function decodeBigNumber (bytes) {\r\n    return Long.fromBuffer(bytes);\r\n  }\r\n\r\n  function decodeTimestamp (bytes) {\r\n    var value = decodeBigNumber(bytes);\r\n    if (value.greaterThan(Long.fromNumber(Number.MIN_VALUE)) && value.lessThan(Long.fromNumber(Number.MAX_VALUE))) {\r\n      return new Date(value.toNumber());\r\n    }\r\n    return value;\r\n  }\r\n\r\n  /*\r\n   * Reads a list from bytes\r\n   */\r\n  function decodeList (bytes, type) {\r\n    var offset = 0;\r\n    //a short containing the total items\r\n    var totalItems = bytes.readUInt16BE(offset);\r\n    offset += 2;\r\n    var list = [];\r\n    for(var i = 0; i < totalItems; i++) {\r\n      //bytes length of the item\r\n      var length = bytes.readUInt16BE(offset);\r\n      offset += 2;\r\n      //slice it\r\n      list.push(decode(bytes.slice(offset, offset+length), [type]));\r\n      offset += length;\r\n    }\r\n    return list;\r\n  }\r\n\r\n  /*\r\n   * Reads a map (key / value) from bytes\r\n   */\r\n  function decodeMap (bytes, type1, type2) {\r\n    var offset = 0;\r\n    //a short containing the total items\r\n    var totalItems = bytes.readUInt16BE(offset);\r\n    offset += 2;\r\n    var map = {};\r\n    for(var i = 0; i < totalItems; i++) {\r\n      var keyLength = bytes.readUInt16BE(offset);\r\n      offset += 2;\r\n      var key = decode(bytes.slice(offset, offset+keyLength), [type1]);\r\n      offset += keyLength;\r\n      var valueLength = bytes.readUInt16BE(offset);\r\n      offset += 2;\r\n      map[key] = decode(bytes.slice(offset, offset+valueLength), [type2]);\r\n      offset += valueLength;\r\n    }\r\n    return map;\r\n  }\r\n\r\n  function encode (item) {\r\n    if (item === null) {\r\n      return null;\r\n    }\r\n    var value = item;\r\n    var type = null;\r\n    var subtype = null;\r\n    if (item.hint) {\r\n      value = item.value;\r\n      type = item.hint;\r\n      if (typeof type === 'string') {\r\n        var typeInfo = dataTypes.getByName(type);\r\n        type = typeInfo.type;\r\n        subtype = typeInfo.subtype;\r\n      }\r\n    }\r\n    if (value === null) {\r\n      return null;\r\n    }\r\n    if (!type) {\r\n      type = guessDataType(value);\r\n      if (!type) {\r\n        throw new TypeError('Target data type could not be guessed, you must specify a hint.', value);\r\n      }\r\n    }\r\n    switch (type) {\r\n      case dataTypes.int:\r\n        return encodeInt(value);\r\n      case dataTypes.float:\r\n        return encodeFloat(value);\r\n      case dataTypes.double:\r\n        return encodeDouble(value);\r\n      case dataTypes.boolean:\r\n        return encodeBoolean(value);\r\n      case dataTypes.text:\r\n      case dataTypes.varchar:\r\n        return encodeString(value);\r\n      case dataTypes.ascii:\r\n        return encodeString(value, 'ascii');\r\n      case dataTypes.uuid:\r\n      case dataTypes.timeuuid:\r\n        return encodeUuid(value);\r\n      case dataTypes.custom:\r\n      case dataTypes.decimal:\r\n      case dataTypes.inet:\r\n      case dataTypes.varint:\r\n      case dataTypes.blob:\r\n        return encodeBlob(value, type);\r\n      case dataTypes.bigint:\r\n      case dataTypes.counter:\r\n        return encodeBigNumber(value, type);\r\n      case dataTypes.timestamp:\r\n        return encodeTimestamp(value, type);\r\n      case dataTypes.list:\r\n      case dataTypes.set:\r\n        return encodeList(value, type, subtype);\r\n      case dataTypes.map:\r\n        return encodeMap(value);\r\n      default:\r\n        throw new TypeError('Type not supported ' + type, value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Try to guess the Cassandra type to be stored, based on the javascript value type\r\n   */\r\n  function guessDataType (value) {\r\n    var dataType = null;\r\n    if (typeof value === 'number') {\r\n      dataType = dataTypes.int;\r\n      if (value % 1 !== 0) {\r\n        dataType = dataTypes.double;\r\n      }\r\n    }\r\n    else if(value instanceof Date) {\r\n      dataType = dataTypes.timestamp;\r\n    }\r\n    else if(value instanceof Long) {\r\n      dataType = dataTypes.bigint;\r\n    }\r\n    else if (typeof value === 'string') {\r\n      dataType = dataTypes.text;\r\n      if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)){\r\n        dataType = dataTypes.uuid;\r\n      }\r\n    }\r\n    else if (value instanceof Buffer) {\r\n      dataType = dataTypes.blob;\r\n    }\r\n    else if (util.isArray(value)) {\r\n      dataType = dataTypes.list;\r\n    }\r\n    else if (value === true || value === false) {\r\n      dataType = dataTypes.boolean;\r\n    }\r\n    return dataType;\r\n  }\r\n\r\n  function encodeInt (value) {\r\n    if (typeof value !== 'number') {\r\n      throw new TypeError(null, value, 'number');\r\n    }\r\n    var buf = new Buffer(4);\r\n    buf.writeInt32BE(value, 0);\r\n    return buf;\r\n  }\r\n\r\n  function encodeFloat (value) {\r\n    if (typeof value !== 'number') {\r\n      throw new TypeError(null, value, 'number');\r\n    }\r\n    var buf = new Buffer(4);\r\n    buf.writeFloatBE(value, 0);\r\n    return buf;\r\n  }\r\n\r\n  function encodeDouble (value) {\r\n    if (typeof value !== 'number') {\r\n      throw new TypeError(null, value, 'number');\r\n    }\r\n    var buf = new Buffer(8);\r\n    buf.writeDoubleBE(value, 0);\r\n    return buf;\r\n  }\r\n\r\n  function encodeTimestamp (value, type) {\r\n    if (value instanceof Date) {\r\n      value = value.getTime();\r\n    }\r\n    return encodeBigNumber (value, type);\r\n  }\r\n\r\n  function encodeUuid (value) {\r\n    if (typeof value === 'string') {\r\n      value = uuid.parse(value, new Buffer(16));\r\n    }\r\n    if (!(value instanceof Buffer)) {\r\n      throw new TypeError('Only Buffer and string objects allowed for UUID values', value, Buffer);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  function encodeBigNumber (value, type) {\r\n    var buf = getBigNumberBuffer(value);\r\n    if (buf === null) {\r\n      throw new TypeError(null, value, Buffer, null, type);\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  function getBigNumberBuffer (value) {\r\n    var buf = null;\r\n    if (value instanceof Buffer) {\r\n      buf = value;\r\n    } else if (value instanceof Long) {\r\n      buf = Long.toBuffer(value);\r\n    } else if (typeof value === 'number') {\r\n      buf = Long.toBuffer(Long.fromNumber(value));\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  function encodeString (value, encoding) {\r\n    if (typeof value !== 'string') {\r\n      throw new TypeError(null, value, 'string');\r\n    }\r\n    return new Buffer(value, encoding);\r\n  }\r\n\r\n  function encodeBlob (value, type) {\r\n    if (!(value instanceof Buffer)) {\r\n      throw new TypeError(null, value, Buffer, null, type);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  function encodeBoolean(value) {\r\n    return new Buffer([(value ? 1 : 0)]);\r\n  }\r\n\r\n  function encodeList(value, type, subtype) {\r\n    if (!util.isArray(value)) {\r\n      throw new TypeError(null, value, Array, null, type);\r\n    }\r\n    if (value.length === 0) {\r\n      return null;\r\n    }\r\n    var parts = [];\r\n    parts.push(getLengthBuffer(value));\r\n    for (var i=0;i<value.length;i++) {\r\n      var item = value[i];\r\n      if (subtype) {\r\n        item = {hint: subtype, value: item};\r\n      }\r\n      var bytes = encode(item);\r\n      //include item byte length\r\n      parts.push(getLengthBuffer(bytes));\r\n      //include item\r\n      parts.push(bytes);\r\n    }\r\n    return Buffer.concat(parts);\r\n  }\r\n\r\n  function encodeMap(value) {\r\n    var parts = [];\r\n    var propCounter = 0;\r\n    for (var key in value) {\r\n      if (!value.hasOwnProperty(key)) continue;\r\n      //add the key and the value\r\n      var keyBuffer = encode(key);\r\n      //include item byte length\r\n      parts.push(getLengthBuffer(keyBuffer));\r\n      //include item\r\n      parts.push(keyBuffer);\r\n      //value\r\n      var valueBuffer = encode(value[key]);\r\n      //include item byte length\r\n      parts.push(getLengthBuffer(valueBuffer));\r\n      //include item\r\n      if (valueBuffer !== null) {\r\n        parts.push(valueBuffer);\r\n      }\r\n      propCounter++;\r\n    }\r\n\r\n    parts.unshift(getLengthBuffer(propCounter));\r\n\r\n    return Buffer.concat(parts);\r\n  }\r\n\r\n  /**\r\n   * Converts a value to string for a query\r\n   */\r\n  function stringifyValue (item) {\r\n    if (item === null || item === undefined) {\r\n      return 'NULL';\r\n    }\r\n    var value = item;\r\n    var type = null;\r\n    var subtype = null;\r\n    if (item.hint) {\r\n      value = item.value;\r\n      type = item.hint;\r\n      if (typeof type === 'string') {\r\n        var typeInfo = dataTypes.getByName(type);\r\n        type = typeInfo.type;\r\n        subtype = typeInfo.subtype;\r\n      }\r\n    }\r\n    if (value === null || value === undefined) {\r\n      return 'NULL';\r\n    }\r\n    if (!type) {\r\n      type = guessDataType(value);\r\n      if (!type && value instanceof types.QueryLiteral) {\r\n        return value.toString();\r\n      }\r\n      if (!type) {\r\n        throw new TypeError('Target data type could not be guessed, you must specify a hint.', value);\r\n      }\r\n    }\r\n    switch (type) {\r\n      case dataTypes.int:\r\n      case dataTypes.float:\r\n      case dataTypes.double:\r\n      case dataTypes.boolean:\r\n      case dataTypes.uuid:\r\n      case dataTypes.timeuuid:\r\n        return value.toString();\r\n      case dataTypes.text:\r\n      case dataTypes.varchar:\r\n      case dataTypes.ascii:\r\n        return quote(value);\r\n      case dataTypes.custom:\r\n      case dataTypes.decimal:\r\n      case dataTypes.inet:\r\n      case dataTypes.varint:\r\n      case dataTypes.blob:\r\n        return stringifyBuffer(value);\r\n      case dataTypes.bigint:\r\n      case dataTypes.counter:\r\n        return stringifyBigNumber(value);\r\n      case dataTypes.timestamp:\r\n        return stringifyDate(value);\r\n      case dataTypes.list:\r\n        return stringifyArray(value, subtype);\r\n      case dataTypes.set:\r\n        return stringifyArray(value, subtype, '{', '}');\r\n      case dataTypes.map:\r\n        return stringifyMap(value);\r\n      default:\r\n        throw new TypeError('Type not supported ' + type, value);\r\n    }\r\n  }\r\n\r\n  function stringifyBuffer(value) {\r\n    return '0x' + value.toString('hex');\r\n  }\r\n\r\n  function stringifyDate (value) {\r\n    return value.getTime().toString();\r\n  }\r\n\r\n  function quote(value) {\r\n    if (typeof value !== 'string') {\r\n      throw new TypeError(null, value, 'string');\r\n    }\r\n    value = value.replace(/'/g, \"''\"); // escape strings with double single-quotes\r\n    return \"'\" + value + \"'\";\r\n  }\r\n\r\n  function stringifyBigNumber (value) {\r\n    var buf = getBigNumberBuffer(value);\r\n    if (buf === null) {\r\n      throw new TypeError(null, value, Long);\r\n    }\r\n    return 'blobAsBigint(' + stringifyBuffer(buf) + ')';\r\n  }\r\n\r\n  function stringifyArray (value, subtype, openChar, closeChar) {\r\n    if (!openChar) {\r\n      openChar = '[';\r\n      closeChar = ']';\r\n    }\r\n    var stringValues = [];\r\n    for (var i = 0; i < value.length; i++) {\r\n      var item = value[i];\r\n      if (subtype) {\r\n        item = {hint: subtype, value: item};\r\n      }\r\n      stringValues.push(stringifyValue(item));\r\n    }\r\n    return openChar + stringValues.join() + closeChar;\r\n  }\r\n\r\n  function stringifyMap (value) {\r\n    var stringValues = [];\r\n    for (var key in value) {\r\n      if (value.hasOwnProperty(key)) {\r\n        stringValues.push(stringifyValue(key) + ':' + stringifyValue(value[key]));\r\n      }\r\n    }\r\n    return '{' + stringValues.join() + '}';\r\n  }\r\n\r\n  /**\r\n   * Gets a buffer containing with 2 bytes representing the array length or the value\r\n   */\r\n  function getLengthBuffer(value) {\r\n    var lengthBuffer = new Buffer(2);\r\n    if (!value) {\r\n      lengthBuffer.writeUInt16BE(0, 0);\r\n    }\r\n    else if (value.length) {\r\n      lengthBuffer.writeUInt16BE(value.length, 0);\r\n    }\r\n    else {\r\n      lengthBuffer.writeUInt16BE(value, 0);\r\n    }\r\n    return lengthBuffer;\r\n  }\r\n\r\n  return {\r\n    decode: decode,\r\n    encode: encode,\r\n    guessDataType: guessDataType,\r\n    stringifyValue: stringifyValue};\r\n})();\r\n\r\nmodule.exports = encoder;","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/lib/types.js":"var util = require('util');\nvar stream = require('stream');\nvar async = require('async');\nvar utils = require('./utils.js');\nvar uuidGenerator = require('node-uuid');\n\n//instances\n\n/**\n * Consistency levels\n */\nvar consistencies = {\n  any:          0x00,\n  one:          0x01,\n  two:          0x02,\n  three:        0x03,\n  quorum:       0x04,\n  all:          0x05,\n  localQuorum:  0x06,\n  eachQuorum:   0x07,\n  localOne:     0x10,\n  getDefault: function () {\n    return this.quorum;\n  }\n};\n\n/**\n * CQL data types\n */\nvar dataTypes = {\n  custom:     0x0000,\n  ascii:      0x0001,\n  bigint:     0x0002,\n  blob:       0x0003,\n  boolean:    0x0004,\n  counter:    0x0005,\n  decimal:    0x0006,\n  double:     0x0007,\n  float:      0x0008,\n  int:        0x0009,\n  text:       0x000a,\n  timestamp:  0x000b,\n  uuid:       0x000c,\n  varchar:    0x000d,\n  varint:     0x000e,\n  timeuuid:   0x000f,\n  inet:       0x0010,\n  list:       0x0020,\n  map:        0x0021,\n  set:        0x0022,\n  getByName:  function(name) {\n    var typeInfo = { name: name.toLowerCase() };\n    var listMatches = /^(list|set)<(\\w+)>$/.exec(typeInfo.name);\n    if (listMatches) {\n      typeInfo.name = listMatches[1];\n      typeInfo.subtype = listMatches[2];\n    }\n    typeInfo.type = this[typeInfo.name];\n    if (typeof typeInfo.type !== 'number') {\n      throw new TypeError('Datatype with name ' + name + ' not valid', null);\n    }\n    return typeInfo;\n  }\n};\n\n/**\n * An integer byte that distinguish the actual message from and to Cassandra\n */\nvar opcodes = {\n  error:        0x00,\n  startup:      0x01,\n  ready:        0x02,\n  authenticate: 0x03,\n  credentials:  0x04,\n  options:      0x05,\n  supported:    0x06,\n  query:        0x07,\n  result:       0x08,\n  prepare:      0x09,\n  execute:      0x0a,\n  register:     0x0b,\n  event:        0x0c,\n  /**\n   * Determines if the code is a valid opcode\n   */\n  isInRange: function (code) {\n    return code > this.error && code > this.event;\n  }\n};\n\n/**\n * Parses a string query and stringifies the parameters\n */\nvar queryParser = {\n  /**\n   * Replaced the query place holders with the stringified value\n   * @param {String} query\n   * @param {Array} params\n   * @param {Function} stringifier\n   */\n  parse: function (query, params, stringifier) {\n    if (!query || !query.length || !params) {\n      return query;\n    }\n    if (!stringifier) {\n      stringifier = function (a) {return a.toString()};\n    }\n    var parts = [];\n    var isLiteral = false;\n    var lastIndex = 0;\n    var paramsCounter = 0;\n    for (var i = 0; i < query.length; i++) {\n      var char = query.charAt(i);\n      if (char === \"'\" && query.charAt(i-1) !== '\\\\') {\n        //opening or closing quotes in a literal value of the query\n        isLiteral = !isLiteral;\n      }\n      if (!isLiteral && char === '?') {\n        //is a placeholder\n        parts.push(query.substring(lastIndex, i));\n        parts.push(stringifier(params[paramsCounter++]));\n        lastIndex = i+1;\n      }\n    }\n    parts.push(query.substring(lastIndex));\n    return parts.join('');\n  }\n};\n\n/**\n * Server error codes returned by Cassandra\n */\nvar responseErrorCodes = {\n  serverError:            0x0000,\n  protocolError:          0x000A,\n  badCredentials:         0x0100,\n  unavailableException:   0x1000,\n  overloaded:             0x1001,\n  isBootstrapping:        0x1002,\n  truncateError:          0x1003,\n  writeTimeout:           0x1100,\n  readTimeout:            0x1200,\n  syntaxError:            0x2000,\n  unauthorized:           0x2100,\n  invalid:                0x2200,\n  configError:            0x2300,\n  alreadyExists:          0x2400,\n  unprepared:             0x2500\n};\n\n/**\n * Type of result included in a response\n */\nvar resultKind = {\n  voidResult:      0x0001,\n  rows:            0x0002,\n  setKeyspace:     0x0003,\n  prepared:        0x0004,\n  schemaChange:    0x0005\n};\n\n/**\n * Generates and returns a RFC4122 v1 (timestamp based) UUID.\n * Uses node-uuid module as generator.\n */\nfunction timeuuid(options, buffer, offset) {\n  return uuidGenerator.v1(options, buffer, offset);\n}\n\n/**\n * Generate and return a RFC4122 v4 UUID.\n * Uses node-uuid module as generator.\n */\nfunction uuid(options, buffer, offset) {\n  return uuidGenerator.v4(options, buffer, offset);\n}\n\n//classes\n\n/**\n * Represents a frame header that could be used to read from a Buffer or to write to a Buffer\n */\nfunction FrameHeader(values) {\n  if (values) {\n    if (values instanceof Buffer) {\n      this.fromBuffer(values);\n    }\n    else {\n      for (var prop in values) {\n        this[prop] = values[prop];\n      }\n    }\n  }\n}\n\n/**\n * The length of the header of the protocol\n */\nFrameHeader.size = 8;\nFrameHeader.prototype.version = 1;\nFrameHeader.prototype.flags = 0x0;\nFrameHeader.prototype.streamId = null;\nFrameHeader.prototype.opcode = null;\nFrameHeader.prototype.bodyLength = 0;\n\nFrameHeader.prototype.fromBuffer = function (buf) {\n  if (buf.length < FrameHeader.size) {\n    //there is not enough data to read the header\n    return;\n  }\n  this.bufferLength = buf.length;\n  this.isResponse = buf[0] & 0x80;\n  this.version = buf[0] & 0x7F;\n  this.flags = buf.readUInt8(1);\n  this.streamId = buf.readInt8(2);\n  this.opcode = buf.readUInt8(3);\n  this.bodyLength = buf.readUInt32BE(4);\n};\n\nFrameHeader.prototype.toBuffer = function () {\n  var buf = new Buffer(FrameHeader.size);\n  buf.writeUInt8(0 + this.version, 0);\n  buf.writeUInt8(this.flags, 1);\n  buf.writeUInt8(this.streamId, 2);\n  buf.writeUInt8(this.opcode, 3);\n  buf.writeUInt32BE(this.bodyLength, 4);\n  return buf;\n};\n\n/**\n * Long constructor, wrapper of the internal library used.\n */\nvar Long = require('long');\n/**\n * Returns a long representation.\n * Used internally for deserialization\n */\nLong.fromBuffer = function (value) {\n  if (!(value instanceof Buffer)) {\n    throw new TypeError('Expected Buffer', value, Buffer);\n  }\n  return new Long(value.readInt32BE(4), value.readInt32BE(0, 4));\n};\n\n/**\n * Returns a big-endian buffer representation of the Long instance\n * @param {Long} value\n */\nLong.toBuffer = function (value) {\n  if (!(value instanceof Long)) {\n    throw new TypeError('Expected Long', value, Long);\n  }\n  var buffer = new Buffer(8);\n  buffer.writeUInt32BE(value.getHighBitsUnsigned(), 0);\n  buffer.writeUInt32BE(value.getLowBitsUnsigned(), 4);\n  return buffer;\n};\n\n/**\n * Wraps a value to be included as literal in a query\n */\nfunction QueryLiteral (value) {\n  this.value = value;\n}\n\nQueryLiteral.prototype.toString = function () {\n  return this.value.toString();\n};\n\n/**\n * Queues callbacks while the condition tests true. Similar behaviour as async.whilst.\n */\nfunction QueueWhile(test, delayRetry) {\n  this.queue = async.queue(function (task, queueCallback) {\n    async.whilst(\n      test,\n      function(cb) {\n        //Retry in a while\n        if (delayRetry) {\n          setTimeout(cb, delayRetry);\n        }\n        else {\n          setImmediate(cb);\n        }\n      },\n      function() {\n        queueCallback(null, null);\n      }\n    );\n  }, 1);\n}\n\nQueueWhile.prototype.push = function (callback) {\n  this.queue.push({}, callback);\n};\n\n/**\n * Readable stream using to yield data from a result or a field\n */\nfunction ResultStream(opt) {\n  stream.Readable.call(this, opt);\n  this.buffer = [];\n  this.paused = true;\n}\n\nutil.inherits(ResultStream, stream.Readable);\n\nResultStream.prototype._read = function() {\n  this.paused = false;\n  if (this.buffer.length === 0) {\n    this._readableState.reading = false;\n  }\n  while (!this.paused && this.buffer.length > 0) {\n    this.paused = this.push(this.buffer.shift());\n  }\n};\n\nResultStream.prototype.add = function (chunk) {\n  this.buffer.push(chunk);\n  this.read(0);\n};\n\n/**\n * Represents a result row\n */\nfunction Row(columns) {\n  this.columns = columns;\n}\n\n/**\n * Returns the cell value.\n * Created for backward compatibility: use row[columnName] instead.\n * @param {String|Number} columnName Name or index of the column\n */\nRow.prototype.get = function (columnName) {\n  if (typeof columnName === 'number') {\n    if (this.columns && this.columns[columnName]) {\n      columnName = this.columns[columnName].name;\n    }\n    else {\n      throw new Error('Column not found');\n    }\n  }\n  return this[columnName];\n};\n\n//error classes\n\n/**\n * Base Error\n */\nfunction DriverError (message, constructor) {\n  if (constructor) {\n    Error.captureStackTrace(this, constructor);\n    this.name = constructor.name;\n  }\n  this.message = message || 'Error';\n  this.info = 'Cassandra Driver Error';\n}\nutil.inherits(DriverError, Error);\n\n\nfunction QueryParserError(e) {\n  QueryParserError.super_.call(this, e.message, this.constructor);\n  this.internalError = e;\n}\nutil.inherits(QueryParserError, DriverError);\n\nfunction TimeoutError (message) {\n  TimeoutError.super_.call(this, message, this.constructor);\n  this.info = 'Represents an error that happens when the maximum amount of time for an operation passed.';\n}\nutil.inherits(TimeoutError, DriverError);\n\nfunction TypeError (message, value, expectedType, actualType, reference) {\n  if (!message) {\n    message = 'Type not supported for operation';\n  }\n  TimeoutError.super_.call(this, message, this.constructor);\n  this.value = value;\n  this.info = 'Represents an error that happens when trying to convert from one type to another.';\n  if (expectedType) {\n    this.expectedType = expectedType;\n  }\n  if (this.actualType) {\n    this.actualType = actualType;\n  }\n  if (this.reference) {\n    this.reference = reference;\n  }\n}\nutil.inherits(TypeError, DriverError);\n\nexports.opcodes = opcodes;\nexports.consistencies = consistencies;\nexports.dataTypes = dataTypes;\nexports.queryParser = queryParser;\nexports.responseErrorCodes = responseErrorCodes;\nexports.resultKind = resultKind;\nexports.timeuuid = timeuuid;\nexports.uuid = uuid;\nexports.FrameHeader = FrameHeader;\nexports.Long = Long;\nexports.QueryLiteral = QueryLiteral;\nexports.QueueWhile = QueueWhile;\nexports.ResultStream = ResultStream;\nexports.Row = Row;\nexports.DriverError = DriverError;\nexports.TimeoutError = TimeoutError;","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/lib/utils.js":"var util = require('util');\n/**\n * Creates a copy of a buffer\n */\nfunction copyBuffer(buf) {\n  var targetBuffer = new Buffer(buf.length);\n  buf.copy(targetBuffer);\n  return targetBuffer;\n}\n\n/**\n * Appends the original stacktrace to the error after a tick of the event loop\n */\nfunction fixStack(stackTrace, error) {\n  error.stack += '\\n  (event loop)\\n' + stackTrace.substr(stackTrace.indexOf(\"\\n\") + 1);\n  return error;\n}\n\n/**\n * Gets the sum of the length of the items of an array\n */\nfunction totalLength (arr) {\n  if (!arr) {\n    return 0;\n  }\n  var total = 0;\n  arr.forEach(function (item) {\n    var length = item.length;\n    length = length ? length : 0;\n    total += length;\n  });\n  return total;\n}\n\n/**\n * Merge the contents of two or more objects together into the first object. Similar to jQuery.extend\n */\nfunction extend(target) {\n  var sources = [].slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    for (var prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  });\n  return target;\n}\n\n/**\n * Sync events: executes the callback when the event (with the same parameters) have been called in all emitters.\n */\nfunction syncEvent(emitters, eventName, context, callback) {\n  var thisKey = '';\n  var eventListener = getListener(eventName, context);\n  emitters.forEach(function (item) {\n    thisKey += '_' + item.constructor.name;\n    item.on(eventName, eventListener);\n  });\n  context[thisKey] = {emittersLength: emitters.length};\n  \n  function getListener(eventName, context) {\n    return function listener () {\n      var argsKey = '_' + eventName + Array.prototype.slice.call(arguments).join('_');\n      var elements = context[thisKey];\n      if (typeof elements[argsKey] === 'undefined') {\n        elements[argsKey] = 0;\n        return;\n      }\n      else if (elements[argsKey] < elements.emittersLength-2){\n        elements[argsKey] = elements[argsKey] + 1;\n        return;\n      }\n      delete elements[argsKey];\n      callback.apply(context, Array.prototype.slice.call(arguments));\n    };\n  }\n}\n\n/**\n * Parses the arguments used by exec methods.\n * Returns an array of parameters, containing also arguments as properties (query, params, consistency, options)\n */\nfunction parseCommonArgs (query, params, consistency, options, callback) {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length < 2 || typeof args[args.length-1] !== 'function') {\n    throw new Error('It should contain at least 2 arguments, with the callback as the last argument.');\n  }\n\n  if(args.length < 5) {\n    options = null;\n    callback = args[args.length-1];\n    if (args.length < 4) {\n      consistency = null;\n      if (typeof params === 'number') {\n        consistency = params;\n        params = null;\n      }\n    }\n    if (args.length < 3) {\n      params = null;\n    }\n  }\n  args.query = query;\n  args.options = options;\n  args.params = params;\n  args.consistency = consistency;\n  args.callback = callback;\n  return args;\n}\n\n\nexports.copyBuffer = copyBuffer;\nexports.extend = extend;\nexports.totalLength = totalLength;\nexports.syncEvent = syncEvent;\nexports.parseCommonArgs = parseCommonArgs;\nexports.fixStack = fixStack;\n","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/lib/streams.js":"var util = require('util');\r\nvar stream = require('stream');\r\nvar Transform = stream.Transform;\r\nvar Writable = stream.Writable;\r\n\r\nvar encoder = require('./encoder.js');\r\nvar types = require('./types.js');\r\nvar utils = require('./utils.js');\r\nvar FrameHeader = types.FrameHeader;\r\nvar FrameReader = require('./readers.js').FrameReader;\r\n\r\n/**\r\n * Transforms chunks, emits data objects {header, chunk}\r\n */\r\nfunction Protocol (options) {\r\n  Transform.call(this, options);\r\n  this.header = null;\r\n  this.headerChunks = [];\r\n  this.bodyLength = 0;\r\n}\r\n\r\nutil.inherits(Protocol, Transform);\r\n\r\nProtocol.prototype._transform = function (chunk, encoding, callback) {\r\n  var error = null;\r\n  try {\r\n    this.transformChunk(chunk);\r\n  }\r\n  catch (err) {\r\n    error = err;\r\n  }\r\n  callback(error);\r\n};\r\n\r\nProtocol.prototype.transformChunk = function (chunk) {\r\n  var bodyChunk = chunk;\r\n\r\n  if (this.header === null) {\r\n    this.headerChunks.push(chunk);\r\n    var length = utils.totalLength(this.headerChunks);\r\n    if (length < FrameHeader.size) {\r\n      return;\r\n    }\r\n    var chunksGrouped = Buffer.concat(this.headerChunks, length);\r\n    this.header = new FrameHeader(chunksGrouped);\r\n    if (length >= FrameHeader.size) {\r\n      bodyChunk = chunksGrouped.slice(FrameHeader.size);\r\n    }\r\n  }\r\n\r\n  this.bodyLength += bodyChunk.length;\r\n  var frameEnded = this.bodyLength >= this.header.bodyLength;\r\n  var header = this.header;\r\n\r\n  var nextChunk = null;\r\n\r\n  if (this.bodyLength > this.header.bodyLength) {\r\n    //We received more than a complete frame\r\n    var previousBodyLength = (this.bodyLength - bodyChunk.length);\r\n\r\n    var nextStart = this.header.bodyLength - previousBodyLength;\r\n    if (nextStart > bodyChunk.length) {\r\n      throw new Error('Tried to slice a received chunk outside boundaries');\r\n    }\r\n    nextChunk = bodyChunk.slice(nextStart);\r\n    bodyChunk = bodyChunk.slice(0, nextStart);\r\n    this.clear();\r\n\r\n    //close loop: parse next chunk before emitting\r\n    this.transformChunk(nextChunk);\r\n  }\r\n  else if (this.bodyLength === this.header.bodyLength) {\r\n    this.clear();\r\n  }\r\n\r\n  this.push({header: header, chunk: bodyChunk, frameEnded: frameEnded});\r\n};\r\n\r\nProtocol.prototype.clear = function () {\r\n  this.header = null;\r\n  this.bodyLength = 0;\r\n  this.headerChunks = [];\r\n};\r\n\r\n/**\r\n * A stream that gets reads header + body chunks and transforms them into header + (row | error)\r\n */\r\nfunction Parser (options) {\r\n  Transform.call(this, options);\r\n  //frames that are streaming, indexed by id\r\n  this.frames = {};\r\n}\r\n\r\nutil.inherits(Parser, Transform);\r\n\r\nParser.prototype._transform = function (item, encoding, callback) {\r\n  var frameInfo = this.frameState(item);\r\n\r\n  var error = null;\r\n  try {\r\n    this.parseBody(frameInfo, item);\r\n  }\r\n  catch (err) {\r\n    error = err;\r\n  }\r\n  callback(error);\r\n\r\n  if (item.frameEnded) {\r\n    //all the parsing finished and it was streamed down\r\n    //emit an item that signals it\r\n    this.emitItem(frameInfo, {frameEnded: true});\r\n  }\r\n};\r\n\r\n/**\r\n * Pushes the item with the header and the provided props to the consumer\r\n */\r\nParser.prototype.emitItem = function (frameInfo, props) {\r\n  //flag that determines if it needs push down the header and props to the consumer\r\n  var pushDown = true;\r\n  if (frameInfo.resultStream) {\r\n    //emit rows into the specified stream\r\n    if (props.row) {\r\n      frameInfo.resultStream.add(props.row);\r\n      pushDown = false;\r\n    }\r\n    else if (props.frameEnded) {\r\n      frameInfo.resultStream.add(null);\r\n    }\r\n    else if (props.error) {\r\n      //Cassandra sent a response error\r\n      frameInfo.resultStream.emit('error', props.error)\r\n    }\r\n  }\r\n  if (pushDown) {\r\n    //push the header and props to be read by consumers\r\n    this.push(utils.extend({header: frameInfo.header}, props));\r\n  }\r\n\r\n};\r\n\r\nParser.prototype.parseBody = function (frameInfo, item) {\r\n  var reader = new FrameReader(item.header, item.chunk);\r\n  if (frameInfo.buffer) {\r\n    reader.unshift(frameInfo.buffer);\r\n    frameInfo.buffer = null;\r\n  }\r\n  switch (item.header.opcode) {\r\n    case types.opcodes.ready:\r\n      return this.emitItem(frameInfo, {ready: true});\r\n    case types.opcodes.authenticate:\r\n      return this.emitItem(frameInfo, {mustAuthenticate: true});\r\n    case types.opcodes.error:\r\n      return this.parseError(frameInfo, reader);\r\n    case types.opcodes.result:\r\n      return this.parseResult(frameInfo, reader);\r\n    default:\r\n      return this.emitItem(frameInfo, {error: new Error('Received invalid opcode: ' + item.header.opcode)});\r\n  }\r\n};\r\n\r\n/**\r\n * Tries to read the error code and message.\r\n * If there is enough data to read, it pushes the header and error. If there isn't, it buffers it.\r\n * @param frameInfo information of the frame being parsed\r\n * @param {FrameReader} reader\r\n */\r\nParser.prototype.parseError = function (frameInfo, reader) {\r\n  try {\r\n    this.emitItem(frameInfo, {error: reader.readError()});\r\n  }\r\n  catch (e) {\r\n    if (e instanceof RangeError) {\r\n      frameInfo.buffer = reader.getBuffer();\r\n      return;\r\n    }\r\n    throw e;\r\n  }\r\n};\r\n\r\n/**\r\n * Tries to read the result in the body of a message\r\n * @param frameInfo Frame information, header / metadata\r\n * @param {FrameReader} reader\r\n */\r\nParser.prototype.parseResult = function (frameInfo, reader) {\r\n  var originalOffset = reader.offset;\r\n  try {\r\n    if (!frameInfo.meta) {\r\n      frameInfo.kind = reader.readInt();\r\n\r\n      if (frameInfo.kind === types.resultKind.prepared) {\r\n        frameInfo.preparedId = utils.copyBuffer(reader.readShortBytes());\r\n      }\r\n      if (frameInfo.kind === types.resultKind.rows ||\r\n          frameInfo.kind === types.resultKind.prepared) {\r\n        frameInfo.meta = reader.readMetadata();\r\n      }\r\n    }\r\n  }\r\n  catch (e) {\r\n    if (e instanceof RangeError) {\r\n      //A controlled error, the kind / metadata is not available to be read yet\r\n      return this.bufferForLater(frameInfo, reader, originalOffset);\r\n    }\r\n    throw e;\r\n  }\r\n  if (frameInfo.kind !== types.resultKind.rows) {\r\n    return this.emitItem(frameInfo, {id: frameInfo.preparedId, meta: frameInfo.meta});\r\n  }\r\n  if (frameInfo.streamField) {\r\n    frameInfo.streamingColumn = frameInfo.meta.columns[frameInfo.meta.columns.length-1].name;\r\n  }\r\n  //it contains rows\r\n  if (reader.remainingLength() > 0) {\r\n    this.parseRows(frameInfo, reader);\r\n  }\r\n};\r\n\r\nParser.prototype.parseRows = function (frameInfo, reader) {\r\n  if (typeof frameInfo.rowLength === 'undefined') {\r\n    try {\r\n      frameInfo.rowLength = reader.readInt();\r\n    }\r\n    catch (e) {\r\n      if (e instanceof RangeError) {\r\n        //there is not enough data to read this row\r\n        this.bufferForLater(frameInfo, reader);\r\n        return;\r\n      }\r\n      throw e;\r\n    }\r\n  }\r\n  if (frameInfo.rowLength === 0) {\r\n    return this.emitItem(frameInfo, {result: {rows: []}});\r\n  }\r\n  var meta = frameInfo.meta;\r\n  frameInfo.rowIndex = frameInfo.rowIndex || 0;\r\n  var stopReading = false;\r\n  for (var i = frameInfo.rowIndex; i < frameInfo.rowLength && !stopReading; i++) {\r\n    this.emit('log', 'info', 'Reading row ' + i);\r\n    if (frameInfo.fieldStream) {\r\n      this.streamField(frameInfo, reader, null, i);\r\n      stopReading = reader.remainingLength() === 0;\r\n      continue;\r\n    }\r\n    var row = new types.Row(meta.columns);\r\n    var rowOffset = reader.offset;\r\n    for(var j = 0; j < meta.columns.length; j++ ) {\r\n      var col = meta.columns[j];\r\n      this.emit('log', 'info', 'Reading cell value for ' + col.name);\r\n      if (col.name !== frameInfo.streamingColumn) {\r\n        var bytes = null;\r\n        try {\r\n          bytes = reader.readBytes();\r\n        }\r\n        catch (e) {\r\n          if (e instanceof RangeError) {\r\n            //there is not enough data to read this row\r\n            this.bufferForLater(frameInfo, reader, rowOffset, i);\r\n            stopReading = true;\r\n            break;\r\n          }\r\n          throw e;\r\n        }\r\n        try\r\n        {\r\n          row[col.name] = encoder.decode(bytes, col.type);\r\n          bytes = null;\r\n        }\r\n        catch (e) {\r\n          throw new ParserError(e, i, j);\r\n        }\r\n        if (j === meta.columns.length -1) {\r\n          //the is no field to stream, emit that the row has been parsed\r\n          this.emitItem(frameInfo, {\r\n            row: row,\r\n            meta: frameInfo.meta,\r\n            byRow: frameInfo.byRow,\r\n            length: frameInfo.rowLength\r\n          });\r\n        }\r\n      }\r\n      else {\r\n        var couldRead = this.streamField(frameInfo, reader, row, i);\r\n        if (couldRead && reader.remainingLength() > 0) {\r\n          //could be next field/row\r\n          continue;\r\n        }\r\n        if (!couldRead) {\r\n          this.bufferForLater(frameInfo, reader, rowOffset, frameInfo.rowIndex);\r\n        }\r\n        stopReading = true;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Streams the content of a field\r\n * @returns {Boolean} true if read from the reader\r\n */\r\nParser.prototype.streamField = function (frameInfo, reader, row, rowIndex) {\r\n  this.emit('log', 'info', 'Streaming field');\r\n  var fieldStream = frameInfo.fieldStream;\r\n  if (!fieldStream) {\r\n    try {\r\n      frameInfo.fieldLength = reader.readInt();\r\n    }\r\n    catch (e) {\r\n      if (e instanceof RangeError) {\r\n        return false;\r\n      }\r\n      throw e;\r\n    }\r\n    if (frameInfo.fieldLength < 0) {\r\n      //null value\r\n      this.emitItem(frameInfo, {\r\n        row: row,\r\n        meta: frameInfo.meta,\r\n        byRow: true,\r\n        length: frameInfo.rowLength\r\n      });\r\n      return true;\r\n    }\r\n    fieldStream = new types.ResultStream();\r\n    frameInfo.streamedSoFar = 0;\r\n    frameInfo.rowIndex = rowIndex;\r\n    frameInfo.fieldStream = fieldStream;\r\n    this.emitItem(frameInfo, {\r\n      row: row,\r\n      meta: frameInfo.meta,\r\n      fieldStream: fieldStream,\r\n      byRow: true,\r\n      length: frameInfo.rowLength\r\n    });\r\n  }\r\n  var availableChunk = reader.read(frameInfo.fieldLength - frameInfo.streamedSoFar);\r\n\r\n  //push into the stream\r\n  fieldStream.add(availableChunk);\r\n  frameInfo.streamedSoFar += availableChunk.length;\r\n  //check if finishing\r\n  if (frameInfo.streamedSoFar === frameInfo.fieldLength) {\r\n    //EOF - Finished streaming this\r\n    fieldStream.push(null);\r\n    frameInfo.fieldStream = null;\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Sets parser options (ie: how to yield the results as they are parsed)\r\n * @param {Number} id Id of the stream\r\n * @param options\r\n */\r\nParser.prototype.setOptions = function (id, options) {\r\n  if (this.frames[id.toString()]) {\r\n    throw new types.DriverError('There was already state for this frame');\r\n  }\r\n  this.frames[id.toString()] = options;\r\n};\r\n\r\n/**\r\n * Gets the frame info from the internal state.\r\n * In case it is not there, it creates it.\r\n * In case the frame ended\r\n */\r\nParser.prototype.frameState = function (item) {\r\n  var frameInfo = this.frames[item.header.streamId];\r\n  if (!frameInfo) {\r\n    frameInfo = this.frames[item.header.streamId] = {};\r\n  }\r\n  if (item.frameEnded) {\r\n    delete this.frames[item.header.streamId];\r\n  }\r\n  frameInfo.header = item.header;\r\n  return frameInfo;\r\n};\r\n\r\n/**\r\n * Buffers for later use as there isn't enough data to read\r\n * @param frameInfo\r\n * @param {FrameReader} reader\r\n * @param {Number} [originalOffset]\r\n * @param {Number} [rowIndex]\r\n */\r\nParser.prototype.bufferForLater = function (frameInfo, reader, originalOffset, rowIndex) {\r\n  if (!originalOffset && originalOffset !== 0) {\r\n    originalOffset = reader.offset;\r\n  }\r\n  frameInfo.rowIndex = rowIndex;\r\n  frameInfo.buffer = reader.slice(originalOffset);\r\n  reader.toEnd();\r\n};\r\n\r\n/**\r\n * Represents a writable streams that emits results\r\n */\r\nfunction ResultEmitter(options) {\r\n  Writable.call(this, options);\r\n  /**\r\n   * Stores the rows for frames that needs to be yielded as one result with many rows\r\n   */\r\n  this.rowBuffer = {};\r\n}\r\n\r\nutil.inherits(ResultEmitter, Writable);\r\n\r\nResultEmitter.prototype._write = function (item, encoding, callback) {\r\n  var error = null;\r\n  try {\r\n    this.each(item);\r\n  }\r\n  catch (err) {\r\n    error = err;\r\n  }\r\n  callback(error);\r\n};\r\n\r\n\r\n/**\r\n * Analyzes the item and emit the corresponding event\r\n */\r\nResultEmitter.prototype.each = function (item) {\r\n  if (item.error || item.result) {\r\n    //no transformation needs to be made\r\n    return this.emit('result', item.header, item.error, item.result);\r\n  }\r\n  if (item.frameEnded) {\r\n    return this.emit('frameEnded', item.header);\r\n  }\r\n  if (item.byRow) {\r\n    //it should be yielded by row\r\n    return this.emit('row', item.header, item.row, item.fieldStream, item.length);\r\n  }\r\n  if (item.row) {\r\n    //it should be yielded as a result\r\n    //it needs to be buffered to an array of rows\r\n    return this.bufferAndEmit(item);\r\n  }\r\n  //its a raw result (object with flags)\r\n  return this.emit('result', item.header, null, item);\r\n};\r\n\r\n/**\r\n * Buffers the rows until the result set is completed and emits the result event.\r\n */\r\nResultEmitter.prototype.bufferAndEmit = function (item) {\r\n  var rows = this.rowBuffer[item.header.streamId];\r\n  if (!rows) {\r\n    rows = this.rowBuffer[item.header.streamId] = [];\r\n  }\r\n  rows.push(item.row);\r\n  if (rows.length === item.length) {\r\n    this.emit('result', item.header, null, {rows: rows, meta: item.meta});\r\n    delete this.rowBuffer[item.header.streamId];\r\n  }\r\n};\r\n\r\nfunction ParserError(err, rowIndex, colIndex) {\r\n  types.DriverError.call(this, err.message, this.constructor);\r\n  this.rowIndex = rowIndex;\r\n  this.colIndex = colIndex;\r\n  this.innerError = err;\r\n  this.info = 'Represents an Error while parsing the result';\r\n}\r\n\r\nutil.inherits(ParserError, types.DriverError);\r\n\r\nexports.Protocol = Protocol;\r\nexports.Parser = Parser;\r\nexports.ResultEmitter = ResultEmitter;","/home/travis/build/npmtest/node-npmtest-node-cassandra-cql/node_modules/node-cassandra-cql/lib/readers.js":"/**\n * Based on https://github.com/isaacbwagner/node-cql3/blob/master/lib/frameParser.js \n * under the MIT License https://github.com/isaacbwagner/node-cql3/blob/master/LICENSE\n */\nvar util = require('util');\nvar utils = require('./utils.js');\nvar types = require('./types.js');\n\n/**\n * Buffer forward reader of CQL binary frames\n */\nfunction FrameReader(header, body) {\n  this.header = header;\n  this.opcode = header.opcode;\n  this.offset = 0;\n  this.buf = body;\n}\n\nFrameReader.prototype.remainingLength = function () {\n  return this.buf.length - this.offset;\n};\n\nFrameReader.prototype.getBuffer = function () {\n  return this.buf;\n};\n\n/**\n * Slices the underlining buffer\n */\nFrameReader.prototype.slice = function (begin, end) {\n  if (typeof end === 'undefined') {\n    end = this.buf.length;\n  }\n  return this.buf.slice(begin, end);\n};\n\n/**\n * Modifies the underlying buffer, it concatenates the given buffer with the original (internalBuffer = concat(bytes, internalBuffer)\n */\nFrameReader.prototype.unshift = function (bytes) {\n  if (this.offset > 0) {\n    throw new Error('Can not modify the underlying buffer if already read');\n  }\n  this.buf = Buffer.concat([bytes, this.buf], bytes.length + this.buf.length);\n};\n\n/**\n * Reads any number of bytes and moves the offset.\n * if length not provided or it's larger than the remaining bytes, reads to end.\n */\nFrameReader.prototype.read = function (length) {\n  var end = this.buf.length;\n  if (typeof length !== 'undefined' && this.offset + length < this.buf.length) {\n    end = this.offset + length;\n  }\n  var bytes = this.slice(this.offset, end);\n  this.offset = end;\n  return bytes;\n};\n\n/**\n * Moves the reader cursor to the end\n */\nFrameReader.prototype.toEnd = function () {\n  this.offset = this.buf.length;\n};\n\nFrameReader.prototype.readInt = function() {\n  var result = this.buf.readInt32BE(this.offset);\n  this.offset += 4;\n  return result;\n};\n\nFrameReader.prototype.readShort = function () {\n  var result = this.buf.readUInt16BE(this.offset);\n  this.offset += 2;\n  return result;\n};\n\nFrameReader.prototype.readByte = function () {\n  var result = this.buf.readUInt8(this.offset);\n  this.offset += 1;\n  return result;\n};\n\nFrameReader.prototype.readString = function () {\n  var length = this.readShort();\n  this.checkOffset(length);\n  var result = this.buf.toString('utf8', this.offset, this.offset+length);\n  this.offset += length;\n  return result;\n};\n\n/**\n * Checks that the new length to read is within the range of the buffer length. Throws a RangeError if not.\n */\nFrameReader.prototype.checkOffset = function (newLength) {\n  if (this.offset + newLength > this.buf.length) {\n    throw new RangeError('Trying to access beyond buffer length');\n  }\n};\n\nFrameReader.prototype.readUUID = function () {\n  var octets = [];\n  for (var i = 0; i < 16; i++) {\n      octets.push(this.readByte());\n  }\n\n  var str = \"\";\n\n  octets.forEach(function(octet) {\n      str += octet.toString(16);\n  });\n\n  return str.slice(0, 8) + '-' + str.slice(8, 12) + '-' + str.slice(12, 16) + '-' + str.slice(16, 20) + '-' + str.slice(20);\n};\n\nFrameReader.prototype.readStringList = function () {\n  var num = this.readShort();\n\n  var list = [];\n\n  for (var i = 0; i < num; i++) {\n      list.push(this.readString());\n  }\n\n  return list;\n};\n/**\n * Reads the amount of bytes that the field has and returns them (slicing them).\n */\nFrameReader.prototype.readBytes = function () {\n  var length = this.readInt();\n  if (length < 0) {\n    return null;\n  }\n  this.checkOffset(length);\n\n  return this.read(length);\n};\n\nFrameReader.prototype.readShortBytes = function () {\n  var length = this.readShort();\n  if (length < 0) {\n    return null;\n  }\n  this.checkOffset(length);\n  return this.read(length);\n};\n\n/* returns an array with two elements */\nFrameReader.prototype.readOption = function () {\n  var id = this.readShort();\n\n  switch(id) {\n    case 0x0000: \n        return [id, this.readString()];\n    case 0x0001:\n    case 0x0002:\n    case 0x0003:\n    case 0x0004:\n    case 0x0005:\n    case 0x0006:\n    case 0x0007:\n    case 0x0008:\n    case 0x0009:\n    case 0x000A:\n    case 0x000B:\n    case 0x000C:\n    case 0x000D:\n    case 0x000E:\n    case 0x000F:\n    case 0x0010:\n        return [id, null];\n    case 0x0020:\n        return [id, this.readOption()];\n    case 0x0021:\n        return [id, [this.readOption(), this.readOption()]];\n    case 0x0022:\n        return [id, this.readOption()];\n  }\n\n  return [id, null];\n};\n\n/* returns an array of arrays */\nFrameReader.prototype.readOptionList = function () {\n  var num = this.readShort();\n  var options = [];\n  for(var i = 0; i < num; i++) {\n      options.push(this.readOption());\n  }\n  return options;\n};\n\nFrameReader.prototype.readInet = function () {\n  //TODO\n};\n\nFrameReader.prototype.readStringMap = function () {\n  var num = this.readShort();\n  var map = {};\n  for(var i = 0; i < num; i++) {\n      var key = this.readString();\n      var value = this.readString();\n      map[key] = value;\n  }\n  return map;\n};\n\nFrameReader.prototype.readStringMultimap = function () {\n  var num = this.readShort();\n  var map = {};\n  for(var i = 0; i < num; i++) {\n      var key = this.readString();\n      map[key] = this.readStringList();\n  }\n  return map;\n};\n\n/**\n * Reads the metadata from a row or a prepared result response\n * @returns {Object}\n */\nFrameReader.prototype.readMetadata = function() {\n  var meta = {};\n  //as used in Rows and Prepared responses\n  var flags = this.readInt();\n\n  var columnCount = this.readInt();\n\n  if(flags & 0x0001) {\n    //only one table spec is provided\n    meta.global_tables_spec = true;\n    meta.keyspace = this.readString();\n    meta.table = this.readString();\n  }\n\n  meta.columns = [];\n\n  for(var i = 0; i < columnCount; i++) {\n    var spec = {};\n    if(!meta.global_tables_spec) {\n      spec.ksname = this.readString();\n      spec.tablename = this.readString();\n    }\n\n    spec.name = this.readString();\n    spec.type = this.readOption();\n    meta.columns.push(spec);\n    //Store the column index by name, to be able to find the column by name\n    meta.columns['_col_' + spec.name] = i;\n  }\n\n  return meta;\n};\n\n/**\n * Try to read a value, in case there is a RangeError (out of bounds) it returns null\n * @param method\n */\nFrameReader.prototype.tryRead = function (method) {\n  var value;\n  try{\n    value = method();\n  }\n  catch (e) {\n    if (e instanceof RangeError) {\n      return null;\n    }\n    throw e;\n  }\n\n};\n\n/**\n * Reads the error from the frame\n * @throws {RangeError}\n * @returns {ResponseError}\n */\nFrameReader.prototype.readError = function () {\n  var code = this.readInt();\n  var message = this.readString();\n  //determine if the server is unhealthy\n  //if true, the client should not retry for a while\n  var isServerUnhealthy = false;\n  switch (code) {\n    case types.responseErrorCodes.serverError:\n    case types.responseErrorCodes.overloaded:\n    case types.responseErrorCodes.isBootstrapping:\n      isServerUnhealthy = true;\n      break;\n  }\n  return new ResponseError(code, message, isServerUnhealthy);\n};\n\nfunction readEvent(data, emitter) {\n  var reader = new FrameReader(data);\n  var event = reader.readString();\n  if(event === 'TOPOLOGY_CHANGE') {\n    emitter.emit(event, reader.readString(), reader.readInet());\n  }\n  else if (event === 'STATUS_CHANGE') {\n    emitter.emit(event, reader.readString(), reader.readInet());\n  }\n  else if (event === 'SCHEMA_CHANGE') {\n    emitter.emit(event, reader.readString(), reader.readString(), reader.readString());\n  }\n  else {\n    throw new Error('Unknown EVENT type: ' + event);\n  }\n}\n\nfunction ResponseError(code, message, isServerUnhealthy) {\n  ResponseError.super_.call(this, message, this.constructor);\n  this.code = code;\n  this.isServerUnhealthy = isServerUnhealthy;\n  this.info = 'Represents a error message from the server';\n}\n\nutil.inherits(ResponseError, types.DriverError);\n\nexports.readEvent = readEvent;\nexports.FrameReader = FrameReader;"}